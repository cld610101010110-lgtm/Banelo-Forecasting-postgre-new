from django.db import models
from django.utils import timezone


# =====================================================
# MODELS SHARED WITH MOBILE APP (PostgreSQL)
# These tables are created and managed by the mobile Room database
# managed = False means Django won't try to create/modify these tables
# =====================================================

class Product(models.Model):
    """
    Product model - matches Mobile Room Entity_Product
    Note: Column names use camelCase to match Room's default naming
    """
    # Primary key - auto-generated by Room
    id = models.AutoField(primary_key=True)

    # Firebase reference ID
    firebase_id = models.CharField(
        max_length=255,
        unique=True,
        null=True,
        blank=True,
        db_column='firebaseId'  # Room camelCase
    )

    # Product details
    name = models.CharField(max_length=255)
    category = models.CharField(max_length=100)
    price = models.FloatField(default=0)
    unit = models.CharField(max_length=50, default='pcs')

    # Stock/Quantity fields
    quantity = models.FloatField(default=0, db_column='quantity')  # Main stock field
    stock = models.FloatField(default=0)  # Legacy field

    # Dual inventory system (if used by mobile)
    inventory_a = models.FloatField(
        default=0,
        db_column='inventoryA',
        help_text='Main Warehouse Stock'
    )
    inventory_b = models.FloatField(
        default=0,
        db_column='inventoryB',
        help_text='Expendable Stock (used for orders)'
    )
    cost_per_unit = models.FloatField(
        default=0,
        db_column='costPerUnit',
        help_text='Cost per unit for ingredients'
    )

    # Image URI
    image_uri = models.TextField(
        null=True,
        blank=True,
        db_column='imageUri'
    )

    # Timestamps (if present in mobile schema)
    created_at = models.DateTimeField(
        auto_now_add=True,
        null=True,
        blank=True,
        db_column='createdAt'
    )
    updated_at = models.DateTimeField(
        auto_now=True,
        null=True,
        blank=True,
        db_column='updatedAt'
    )

    def __str__(self):
        return self.name

    class Meta:
        db_table = 'products'
        managed = False  # Table managed by mobile app


class Sale(models.Model):
    """
    Sale model - matches Mobile Room Entity_Sale
    """
    id = models.AutoField(primary_key=True)

    # Product reference
    product_firebase_id = models.CharField(
        max_length=255,
        null=True,
        blank=True,
        db_column='productFirebaseId'
    )
    product_name = models.CharField(
        max_length=255,
        db_column='productName'
    )

    # Sale details
    category = models.CharField(max_length=100)
    quantity = models.FloatField()
    price = models.FloatField(null=True, blank=True)
    total = models.FloatField(null=True, blank=True)

    # Order date
    order_date = models.DateTimeField(db_column='orderDate')

    # Timestamps
    created_at = models.DateTimeField(
        auto_now_add=True,
        null=True,
        blank=True,
        db_column='createdAt'
    )

    def __str__(self):
        return f"{self.product_name} - {self.quantity} - {self.order_date}"

    class Meta:
        db_table = 'sales'
        managed = False  # Table managed by mobile app
        ordering = ['-order_date']


class Recipe(models.Model):
    """
    Recipe model - matches Mobile Room Entity_Recipe
    """
    # Room typically uses 'id' as primary key, or 'recipe_id' with @PrimaryKey
    id = models.AutoField(primary_key=True)

    # Firebase IDs
    firebase_id = models.CharField(
        max_length=255,
        unique=True,
        db_index=True,
        db_column='firebaseId'
    )
    product_firebase_id = models.CharField(
        max_length=255,
        db_index=True,
        db_column='productFirebaseId'
    )

    # Product info
    product_name = models.CharField(
        max_length=255,
        db_column='productName'
    )
    product_number = models.IntegerField(
        default=0,
        db_column='productId'  # May be 'productId' or 'productNumber' in Room
    )

    # Timestamps
    created_at = models.DateTimeField(
        auto_now_add=True,
        null=True,
        blank=True,
        db_column='createdAt'
    )
    updated_at = models.DateTimeField(
        auto_now=True,
        null=True,
        blank=True,
        db_column='updatedAt'
    )

    def __str__(self):
        return f"Recipe: {self.product_name}"

    class Meta:
        db_table = 'recipes'
        managed = False  # Table managed by mobile app


class RecipeIngredient(models.Model):
    """
    RecipeIngredient model - matches Mobile Room Entity_RecipeIngredient
    """
    id = models.AutoField(primary_key=True)

    # Firebase IDs
    firebase_id = models.CharField(
        max_length=255,
        null=True,
        blank=True,
        db_column='firebaseId'
    )
    recipe_firebase_id = models.CharField(
        max_length=255,
        db_index=True,
        db_column='recipeFirebaseId'
    )
    ingredient_firebase_id = models.CharField(
        max_length=255,
        db_index=True,
        db_column='ingredientFirebaseId'
    )

    # Ingredient details
    ingredient_name = models.CharField(
        max_length=255,
        db_column='ingredientName'
    )
    quantity_needed = models.FloatField(db_column='quantityNeeded')
    unit = models.CharField(max_length=50, default='g')

    # Recipe foreign key (if Room creates this)
    recipe_id = models.IntegerField(
        null=True,
        blank=True,
        db_column='recipeId'
    )

    # Timestamps
    created_at = models.DateTimeField(
        auto_now_add=True,
        null=True,
        blank=True,
        db_column='createdAt'
    )

    def __str__(self):
        return f"{self.ingredient_name}: {self.quantity_needed} {self.unit}"

    class Meta:
        db_table = 'recipe_ingredients'
        managed = False  # Table managed by mobile app


# =====================================================
# MODELS FOR WASTE TRACKING (May be mobile or web-only)
# =====================================================

class WasteLog(models.Model):
    """
    Waste tracking model - for tracking product waste/spoilage
    Set managed = False if mobile app manages this table
    """
    id = models.AutoField(primary_key=True)

    # Product reference
    product_firebase_id = models.CharField(
        max_length=255,
        db_column='productFirebaseId'
    )
    product_name = models.CharField(
        max_length=255,
        db_column='productName'
    )

    # Waste details
    quantity = models.FloatField()
    reason = models.CharField(max_length=255)  # e.g., 'Expired', 'Damaged', 'Spoiled'
    category = models.CharField(max_length=100, null=True, blank=True)

    # Recording info
    waste_date = models.DateTimeField(db_column='wasteDate')
    recorded_by = models.CharField(
        max_length=255,
        null=True,
        blank=True,
        db_column='recordedBy'
    )

    # Timestamps
    created_at = models.DateTimeField(
        auto_now_add=True,
        null=True,
        blank=True,
        db_column='createdAt'
    )

    def __str__(self):
        return f"{self.product_name} - {self.quantity} - {self.reason}"

    class Meta:
        db_table = 'waste_logs'
        managed = True  # Django will create this table if needed
        ordering = ['-waste_date']


# =====================================================
# MODELS FOR AUDIT TRAIL (Web-only typically)
# =====================================================

class AuditTrail(models.Model):
    """
    Audit trail model - for tracking user actions
    """
    id = models.AutoField(primary_key=True)

    # Action details
    action = models.CharField(max_length=255)  # e.g., 'Product Updated', 'Sale Created'
    details = models.TextField(null=True, blank=True)

    # User info
    user_id = models.CharField(
        max_length=255,
        null=True,
        blank=True,
        db_column='userId'
    )
    user_name = models.CharField(
        max_length=255,
        null=True,
        blank=True,
        db_column='userName'
    )

    # Timestamp
    timestamp = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.action} by {self.user_name} at {self.timestamp}"

    class Meta:
        db_table = 'audit_trail'
        managed = True  # Django will create this table
        ordering = ['-timestamp']


# =====================================================
# DJANGO-MANAGED MODELS (For ML/Forecasting)
# These tables are created and managed by Django
# =====================================================

class MLPrediction(models.Model):
    """
    ML Prediction model - stores forecasting predictions
    Managed by Django, not mobile app
    """
    id = models.AutoField(primary_key=True)

    # Product reference (by firebase_id since Product uses managed=False)
    product_firebase_id = models.CharField(
        max_length=255,
        unique=True,
        default='',
        db_column='productFirebaseId'
    )
    product_name = models.CharField(
        max_length=255,
        null=True,
        blank=True,
        default='',
        db_column='productName'
    )

    # Prediction data
    predicted_daily_usage = models.FloatField(db_column='predictedDailyUsage')
    avg_daily_usage = models.FloatField(db_column='avgDailyUsage')
    trend = models.FloatField()
    confidence_score = models.FloatField(db_column='confidenceScore')
    data_points = models.IntegerField(db_column='dataPoints')

    # Timestamps
    last_updated = models.DateTimeField(auto_now=True, db_column='lastUpdated')

    def __str__(self):
        return f"{self.product_name} - Prediction"

    class Meta:
        db_table = 'ml_predictions'
        managed = True  # Django manages this table


class MLModel(models.Model):
    """
    ML Model metadata - tracks training status
    Managed by Django, not mobile app
    """
    id = models.AutoField(primary_key=True)

    name = models.CharField(max_length=100, unique=True)
    is_trained = models.BooleanField(default=False, db_column='isTrained')
    last_trained = models.DateTimeField(null=True, blank=True, db_column='lastTrained')
    total_records = models.IntegerField(default=0, db_column='totalRecords')
    products_analyzed = models.IntegerField(default=0, db_column='productsAnalyzed')
    predictions_generated = models.IntegerField(default=0, db_column='predictionsGenerated')
    accuracy = models.IntegerField(default=85)
    model_type = models.CharField(
        max_length=200,
        default='Linear Regression (Moving Average)',
        db_column='modelType'
    )
    training_period_days = models.IntegerField(default=90, db_column='trainingPeriodDays')

    def __str__(self):
        return self.name

    class Meta:
        db_table = 'ml_models'
        managed = True  # Django manages this table
